{"version":3,"sources":["../../app/helpers/action.helper.js"],"names":["ms","require","MessagingAction","constructor","settings","utils","MessagingChannel","successful_rpc","ping_count","retry_rpc","stringify_payload","send","queue_name","queue_message","undefined","Error","self","channel","create","connection","host","options","user","pass","assertQueue","output","JSON","stringify","the_queue","sendToQueue","Buffer","close","process","env","NODE_ENV","console","log","receive","callback","TypeError","consume","msg","ack","parse","content","toString","create_task","payload","durable","persistent","queue_worker","prefetch","ch","noAck","rpc_client","correlationId","consumed","q","exclusive","consumer","queue","properties","deleteQueue","queue_args","replyTo","arguments","ttl","Number","isInteger","setTimeout","cancel","consumerTag","rpc_server","activity","reply","publish","exchange_name","exchange_message","assertExchange","subscribe","bindQueue","ping","ping_interval","npm_package_name","interval","setInterval"],"mappings":"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","file":"action.helper.js","sourcesContent":["const ms = require('ms')\r\n\r\n//TODO:: Add deeper unit test on subscribe, publish and ping\r\nexport class MessagingAction {\r\n  \r\n  // Depedency Injection:\r\n  constructor({ settings, utils, MessagingChannel, successful_rpc } = {}) {\r\n    // a service for handling AMQP channel creation\r\n    this.MessagingChannel = MessagingChannel;\r\n    \r\n    // configuration settings\r\n    this.settings = settings;\r\n    \r\n    // messaging utilities function helper\r\n    this.utils = utils || null;\r\n    \r\n    // other tracked parameters\r\n    this.ping_count = 0;\r\n    this.retry_rpc = 0;\r\n    this.successful_rpc = successful_rpc || false;\r\n    this.stringify_payload;\r\n  }\r\n  \r\n  /**\r\n  * async send - send simple payload to specify queue,\r\n  *              used together with async RECEIVE\r\n  * @param  {String} queue_name      queue name\r\n  * @param  {Any} queue_message      the payload\r\n  * @return {Promise}                promise of true\r\n  */\r\n  async send(queue_name, queue_message){\r\n    \r\n    if(queue_name === undefined || queue_message === undefined){\r\n      throw new Error('Queue name and queue message is undefined')\r\n    }\r\n    \r\n    let self = this;\r\n    \r\n    let channel = await this.MessagingChannel.create(\r\n      this.settings.connection.host,\r\n      this.settings.connection.options.user,\r\n      this.settings.connection.options.pass\r\n    );\r\n    \r\n    await channel.assertQueue(queue_name);\r\n    \r\n    let output = JSON.stringify(queue_message);\r\n    \r\n    let the_queue = await channel.sendToQueue(queue_name, new Buffer(output));\r\n    \r\n    await channel.close()\r\n    \r\n    if (process.env.NODE_ENV !== \"test\") console.log(`[o] Sent '${output}'`);\r\n    \r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * async receive - receive simple payload from the queue,\r\n  *                 used together with async SEND\r\n  * @param  {String} queue_name    queue name\r\n  * @param  {Function} callback    callback function with params(payload)\r\n  */\r\n  async receive(queue_name, callback){\r\n    \r\n    if(!queue_name || !callback){\r\n      throw new TypeError()\r\n    }\r\n    \r\n    let self = this;\r\n    \r\n    let channel = await this.MessagingChannel.create(\r\n      this.settings.connection.host,\r\n      this.settings.connection.options.user,\r\n      this.settings.connection.options.pass\r\n    );\r\n    \r\n    await channel.assertQueue(queue_name);\r\n    channel.consume(queue_name, function(msg) {\r\n      if (msg !== null) {\r\n        channel.ack(msg);\r\n        callback(JSON.parse(msg.content.toString()));\r\n      }\r\n    });\r\n    \r\n  }\r\n  \r\n  /**\r\n  * async create_task - request some task to be done, not waiting for the result,\r\n  *                     but will try to recover task if worker failed to process the work,\r\n  *                     used to together with create_task\r\n  *\r\n  * @param  {type} queue_name=null description\r\n  * @param  {type} payload=null    description\r\n  * @param  {type} durable=true    description\r\n  * @param  {type} persistent=true description\r\n  * @return {type}                 description\r\n  */\r\n  async create_task(queue_name=null, payload=null, durable=true, persistent=true){\r\n    \r\n    if(queue_name===null || payload===null){\r\n      throw new Error('Queue name and payload is required, as first and second params');\r\n    }\r\n    \r\n    let self = this;\r\n    let channel = await this.MessagingChannel.create(\r\n      this.settings.connection.host,\r\n      this.settings.connection.options.user,\r\n      this.settings.connection.options.pass\r\n    );\r\n    \r\n    await channel.assertQueue(queue_name, {durable: durable});\r\n    \r\n    this.stringify_payload = JSON.stringify(payload);\r\n    \r\n    let the_queue = channel.sendToQueue(queue_name, new Buffer(this.stringify_payload), {persistent: persistent});\r\n  }\r\n  \r\n  /**  \r\n  * async queue_worker - setup service worker for processing some task,\r\n  *                      used to together with create_task\r\n  *\r\n  * @param  {type} queue_name=null description\r\n  * @param  {type} prefetch=3      description\r\n  * @param  {type} durable=true    description\r\n  * @return {type}                 description\r\n  */\r\n  async queue_worker(queue_name=null, prefetch=3, durable=true){\r\n    \r\n    if(queue_name===null){\r\n      throw new Error('Queue name is required, as the first params');\r\n    }\r\n    \r\n    let self = this;\r\n    let channel = await this.MessagingChannel.create(\r\n      this.settings.connection.host,\r\n      this.settings.connection.options.user,\r\n      this.settings.connection.options.pass\r\n    );\r\n    \r\n    await channel.assertQueue(queue_name, {durable});\r\n    \r\n    channel.prefetch(prefetch);\r\n    \r\n    channel.consume(queue_name, function(msg) {\r\n      if (msg !== null) {\r\n        // events[queue_name](msg.content);\r\n        ch.ack(msg);\r\n      }\r\n    }, {noAck: false});\r\n  }\r\n  \r\n  \r\n  /**\r\n  * async rpc_client - request some task to be done from rpc_server and wait for the result,\r\n  *                    used together with rpc_server\r\n  *\r\n  * @param  {String} queue_name=null           description\r\n  * @param  {Any} payload=null                 description\r\n  * @param  {String} correlationId=null        description\r\n  * @param  {Function} callback=null  description\r\n  */\r\n  async rpc_client(queue_name=null, payload=null, correlationId=null, callback=null, options){\r\n    if(queue_name===null || payload===null){\r\n      throw new Error('Queue name and payload is required, as first and second params');\r\n    }\r\n    \r\n    if(correlationId===null || callback===null){\r\n      throw new Error('correlationId and callback is required, as third and fourth params');\r\n    }\r\n    \r\n    let self = this;\r\n    \r\n    let channel = await self.MessagingChannel.create(\r\n      this.settings.connection.host,\r\n      this.settings.connection.options.user,\r\n      this.settings.connection.options.pass\r\n    );\r\n    \r\n    let consumed = false;\r\n    \r\n    let q = await channel.assertQueue('', {exclusive: true, });\r\n    \r\n    let consumer = await channel.consume(q.queue, async function(msg) {\r\n      if (msg && msg.properties.correlationId === correlationId) {\r\n        consumed = true;\r\n        await callback(msg, channel);\r\n        self.successful_rpc = true;\r\n        await channel.deleteQueue(q.queue)\r\n      }\r\n    }, {noAck: true});\r\n    \r\n    self.stringify_payload = JSON.stringify(payload);\r\n    \r\n    let queue_args = { correlationId, replyTo: q.queue, arguments:{} };\r\n    \r\n    if(options){\r\n      if(options.ttl){\r\n        if(!Number.isInteger(options.ttl)){\r\n          //Convert to integer with ms\r\n          options.ttl = ms(options.ttl);\r\n        }\r\n        setTimeout(async () => {\r\n          if(!consumed){\r\n            await channel.cancel(consumer.consumerTag)\r\n            await channel.deleteQueue(q.queue);\r\n            throw new Error(`Asker timeout in ${options.ttl} miliseconds with queue_name: ${queue_name}`)\r\n          }\r\n        }, options.ttl);\r\n      }\r\n    }\r\n    \r\n    \r\n    \r\n    let the_queue = channel.sendToQueue(queue_name, new Buffer(self.stringify_payload),\r\n    queue_args);\r\n  }\r\n  \r\n  /**\r\n  * async rpc_server - setup service service server for processing some task then give response immediately after finished,\r\n  *                    used together with rpc_client\r\n  *\r\n  * @param  {type} queue_name=null description\r\n  * @param  {type} activity=null   description\r\n  * @param  {type} prefetch=3      description\r\n  * @return {type}                 description\r\n  */\r\n  async rpc_server(queue_name=null, activity=null, prefetch=3){\r\n    if(queue_name===null || activity===null){\r\n      throw new Error('Queue name and activity is required, as the first and second params');\r\n    }\r\n    \r\n    let self = this;\r\n    let channel = await this.MessagingChannel.create(\r\n      this.settings.connection.host,\r\n      this.settings.connection.options.user,\r\n      this.settings.connection.options.pass\r\n    );\r\n    \r\n    await channel.assertQueue(queue_name, { durable: false });\r\n    \r\n    channel.prefetch(prefetch);\r\n    \r\n    channel.consume(queue_name, async function reply(msg) {\r\n      await activity(msg, channel);\r\n    });\r\n    \r\n  }\r\n  \r\n  async publish(exchange_name, exchange_message){\r\n    \r\n    if(!exchange_name){\r\n      throw new Error('exchange_name is not defined')\r\n    }\r\n    \r\n    if(!exchange_message){\r\n      throw new Error('exchange_message is not defined')\r\n    }\r\n    \r\n    let self = this;\r\n    \r\n    let channel = await this.MessagingChannel.create(\r\n      this.settings.connection.host,\r\n      this.settings.connection.options.user,\r\n      this.settings.connection.options.pass\r\n    );\r\n    \r\n    channel.assertExchange(exchange_name, 'fanout', {durable: false, exclusive: true});\r\n    \r\n    let output = JSON.stringify(exchange_message);\r\n    \r\n    channel.publish(exchange_name, '', new Buffer(output));\r\n    \r\n    if(process.env == \"test\"){\r\n      console.log(`[o] sent '${output}'`)\r\n    }\r\n    \r\n    return true;\r\n  }\r\n  \r\n  async subscribe(exchange_name, callback){\r\n    \r\n    if(!exchange_name){\r\n      throw new Error(\"exchange_name is not defined\")\r\n    }\r\n    \r\n    if(!callback){\r\n      throw new Error(\"callback is not defined\")\r\n    }\r\n    \r\n    let self = this;\r\n    \r\n    let channel = await this.MessagingChannel.create(\r\n      this.settings.connection.host,\r\n      this.settings.connection.options.user,\r\n      this.settings.connection.options.pass\r\n    );\r\n    \r\n    channel.assertExchange(exchange_name, 'fanout', {durable: false}) \r\n    \r\n    let queue_name = await channel.assertQueue('', {exclusive: true})\r\n    \r\n    await channel.bindQueue(queue_name.queue, exchange_name, '')\r\n    \r\n    channel.consume(queue_name.queue, msg=>{\r\n      callback(JSON.parse(msg.content.toString()))\r\n    }, {noAck: true})\r\n  }\r\n  \r\n  async ping(ping_interval = 3000){\r\n    let self = this;\r\n    \r\n    let queue_name = `${process.env.npm_package_name}_heartbeat`\r\n    \r\n    let interval = await setInterval(async ()=>{\r\n      \r\n      self.ping_count++;\r\n      \r\n      await this.publish(`${process.env.npm_package_name}_heartbeat`, 'beat')\r\n      \r\n    }, ping_interval)\r\n    \r\n    return interval;\r\n  }\r\n  \r\n};\r\n"]}
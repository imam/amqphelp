{"version":3,"sources":["../../app/helpers/base.js"],"names":["chance","require","ms","module","exports","Base","constructor","settings","utils","messagingChannel","actions","MessagingChannel","statuses","_attacher","service_name","process","env","npm_package_name","_getAttacher","attacher_name","TypeError","findLast","name","registerServiceName","registerAttacher","attacher","push","model","schema_name","schema","services_to","Error","options","_servicesToMapper","_attachToAttacher","self","current_service","map","service","create","update","delete","isPlainObject","value","modelReceive","receiver","_init","ask","action","payload","NODE_ENV","console","log","JSON","stringify","opts","ttl","Number","isInteger","expired_at","Date","now","Promise","resolve","correlation","geohash","rpc_client","entity_from","response","parse","content","toString","answer","callback","rpc_server","msg","channel","parsed_content","expired_at_in_date","toDateString","toTimeString","ack","callback_result","e","error_message","message","sendToQueue","properties","replyTo","Buffer","correlationId"],"mappings":"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","file":"base.js","sourcesContent":["import statuses               from './statuses.helper';\r\nimport { MessagingChannel }   from './channel.helper';\r\nimport { MessagingAction }    from './action.helper';\r\nimport { MessagingUtil }      from './util.helper';\r\nimport _ from 'lodash';\r\n\r\nlet chance = require('chance');\r\nlet ms = require('ms');\r\n\r\nmodule.exports  = class Base{\r\n    constructor({settings}){\r\n        this.utils = new MessagingUtil();\r\n        this.settings = settings;\r\n        this.messagingChannel = new MessagingChannel({ utils: this.utils });\r\n        this.actions = new MessagingAction({ settings: this.settings, utils: this.utils, MessagingChannel: this.messagingChannel });\r\n        this.statuses = statuses;\r\n        this._attacher = [];\r\n        this.service_name = process.env.npm_package_name;\r\n        \r\n        this.chance = new chance;\r\n    }\r\n    \r\n    _getAttacher(attacher_name){\r\n        if(!attacher_name){\r\n            throw new TypeError('attacher_name is not defined')\r\n        }\r\n        \r\n        return _.findLast(this._attacher, { name: attacher_name })\r\n    }\r\n    \r\n    /** \r\n    * Register the current service name\r\n    */\r\n    registerServiceName(service_name){\r\n        if(!service_name){\r\n            throw new TypeError('service_name is not defined')\r\n        }\r\n        \r\n        return this.service_name = service_name;\r\n    }\r\n    \r\n    /**\r\n    * Add attacher to singleton\r\n    *\r\n    * @param {string} name Attachers name\r\n    * @param {object} attacher Object\r\n    */\r\n    registerAttacher(name, attacher){\r\n        \r\n        if(!name){\r\n            throw new TypeError('name is not defined')\r\n        }\r\n        \r\n        if(!attacher){\r\n            throw new TypeError('attacher is not defined')\r\n        }\r\n        \r\n        this._attacher.push({\r\n            name,\r\n            attacher\r\n        })\r\n    }\r\n    \r\n    /**\r\n    * Model to send\r\n    *\r\n    * @param {string} attacher_name\r\n    * @param {string} schema Model schema\r\n    * @param {string} services Services to send the message to\r\n    */\r\n    model(attacher_name, schema_name, schema, services_to){\r\n        if(!attacher_name){\r\n            throw new Error('Attacher name is empty')\r\n        }\r\n        if(!schema_name){\r\n            throw new Error('Schema name is empty')\r\n        }\r\n        if(!schema){\r\n            throw new Error('Schema is empty')\r\n        }\r\n        if(!services_to){\r\n            throw new Error('Services to send is empty')\r\n        }\r\n        let attacher = this._getAttacher(attacher_name);\r\n        \r\n        let options = services_to;\r\n        services_to = this._servicesToMapper(services_to);\r\n        \r\n        this._attachToAttacher(attacher, schema_name, schema, services_to, options);\r\n    }\r\n    \r\n    _attachToAttacher(attacher, schema_name, schema, services_to, options){\r\n        \r\n        if(!attacher){\r\n            throw new Error('attacher is not defined')\r\n        }\r\n        \r\n        if(!schema_name){\r\n            throw new Error('schema_name is not defined')\r\n        }\r\n        \r\n        if(!schema){\r\n            throw new Error('schema is not defined')\r\n        }\r\n        \r\n        if(!services_to){\r\n            throw new Error('services_to is not defined')\r\n        }\r\n        \r\n        let self = this;\r\n        let current_service = this.service_name;\r\n        \r\n        _.map(services_to, service=>{\r\n            attacher.attacher.create(`create_${schema_name}_from_${current_service}_for_${service}`, schema_name, current_service, service, schema, self, options)\r\n            attacher.attacher.update(`update_${schema_name}_from_${current_service}_for_${service}`, schema_name, current_service, service, schema, self, options)\r\n            attacher.attacher.delete(`delete_${schema_name}_from_${current_service}_for_${service}`, schema_name, current_service, service, schema, self, options)\r\n        })\r\n    }\r\n    \r\n    // Get all services name and map it into single array\r\n    _servicesToMapper(services_to){\r\n        if(!services_to){\r\n            throw new Error('services_to is not defined')\r\n        }\r\n        return _(services_to).map(service => {\r\n            if (_.isPlainObject(service)) {\r\n                if (service.name) {\r\n                    return service.name;\r\n                }\r\n                throw new Error('Name is not defined in object');\r\n            }\r\n            return service;\r\n        }).value();\r\n    }\r\n    \r\n    /**\r\n    * Receiver from model entity\r\n    */\r\n    modelReceive(receiver){\r\n        if(!receiver){\r\n            throw new TypeError('receiver is not defined')\r\n        }\r\n        receiver._init(this);\r\n    }\r\n    \r\n    ask(service, action, payload, options){\r\n        \r\n        if(!service){\r\n            throw new TypeError('service is not defined')\r\n        }\r\n        \r\n        if(!action){\r\n            throw new TypeError('action is not defined')\r\n        }\r\n        \r\n        if(!payload){\r\n            throw new TypeError('payload is not defined')\r\n        }\r\n        \r\n        if(process.env.NODE_ENV !== 'test'){\r\n            console.log(`asking ${service} for ${action} with ${JSON.stringify(payload)}`)\r\n        }\r\n        \r\n        let opts = {\r\n            ttl: 4000\r\n        }\r\n        \r\n        if(options && options.ttl){\r\n            if(!Number.isInteger(options.ttl)){\r\n                options.ttl = ms(options.ttl)\r\n            }\r\n            opts.ttl = options.ttl;\r\n        }\r\n        \r\n        let expired_at = Date.now() + opts.ttl;\r\n        \r\n        return new Promise(resolve=>{\r\n            let correlation = this.chance.geohash()\r\n            this.actions.rpc_client(`ask_${action}_from_${service}`, {entity_from: process.env.npm_package_name, expired_at, payload}, correlation, response=>{\r\n                resolve(JSON.parse(response.content.toString()))\r\n            }, opts)\r\n        })\r\n    }\r\n    \r\n    answer(action, callback){\r\n        \r\n        if(!action){\r\n            throw new TypeError('action is not defined')\r\n        }\r\n        \r\n        if(!callback){\r\n            throw new TypeError('callback is not defined')\r\n        }\r\n        \r\n        this.actions.rpc_server(`ask_${action}_from_${this.service_name}`, async(msg, channel)=>{\r\n            let parsed_content = JSON.parse(msg.content.toString());\r\n            if(Date.now() > parsed_content.expired_at){\r\n                let expired_at_in_date = new Date()\r\n                console.log(`skipped one ${action} request from ${parsed_content.entity_from} because it's expired at ${expired_at_in_date.toDateString()} ${expired_at_in_date.toTimeString()}`)    \r\n                channel.ack(msg)\r\n                return true;\r\n            }\r\n            console.log(`answering ${action} from ${JSON.parse(msg.content.toString()).entity_from}`)\r\n            let callback_result;\r\n            try{\r\n                callback_result = await callback(JSON.parse(msg.content.toString()).payload);\r\n            } catch(e){\r\n                callback_result = {error_message: `Error in answerer with message: ${e.message}`}\r\n                console.log(`Error answering a message from ${JSON.parse(msg.content.toString()).entity_from} to ${action} with message: ${e.message}`)\r\n            }\r\n            if(!callback_result){\r\n                callback_result = true\r\n            }\r\n            \r\n            if(Date.now() > parsed_content.expired_at){\r\n                let expired_at_in_date = new Date()\r\n                console.log(`cancelled to send one ${action} request to ${parsed_content.entity_from} because it's expired at ${expired_at_in_date.toDateString()} ${expired_at_in_date.toTimeString()}`)    \r\n                channel.ack(msg)\r\n                return true;\r\n            }\r\n            channel.sendToQueue(msg.properties.replyTo, new Buffer(JSON.stringify(callback_result)), {correlationId: msg.properties.correlationId})\r\n            channel.ack(msg)\r\n        })\r\n        \r\n    }\r\n    \r\n}\r\n"]}